// vim: tabstop=4 shiftwidth=4 textwidth=79 expandtab
/**
 * $Id$
 * 
 * Optimize path and location data generated by the ShowImage editor by
 * flattening mulitple overlapping nodes, adding nodes at intersections,
 * and compressing path vectors into a graph structure. 
 */

import java.awt.*;
import java.io.*;
import java.util.*;

/**
 * Path Optimize
 * 
 * This program creates optimized path data to be fead into a script.
 * The program takes in raw data generated from ShowImage.java
 * vectors of vectors of points (paths) and locations and 
 * merges them into a connected graph with path compression.  
 * @author David Lindquist and Michael Kelly
 *
 */
public class PathOptimize
{
	/**
	 * General debug flag...will set all flags to false if set to false
	 */
	public static boolean debugOn = false;
	/**
	 * Debug flag for debugging intersection()
	 */
	public static boolean intersectDebug = false;
	/**
	 * Debug flag for the binary writing of binary GraphPoint data
	 */
	public static boolean debugBinaryGraphPoints = false;
	/**
	 * Debug flag for the binary writing of binary Edge data
	 */
	public static boolean debugBinaryEdges = false;
	/**
	 * Debug flag for the binary writing of location data
	 */
	public static boolean debugBinaryLocations = false;
	/**
	 * Debug flag for the conversion of PathPoints to GraphPoints
	 */
	public static boolean debugPPtoGP = false;
	
	// These fields only hold data from readData
    private Vector <Vector<Point>>readPaths; // Vector of paths
    private Vector <Location>readLocations;  // Vector of locations 
											 // (see class Locations)

	// Container for PathPoints
    private Vector <PathPoint> pathPoints;
    
	// Container for GraphPoints
    private Vector <GraphPoint> graphPoints;
    
    // These fields are for the vectors to be written out in a format
    // that can be read by ShowImage
    private Vector <Vector<Point>> outPaths;
    private Vector <Location> outLocations;
    private Vector <Edge> outEdges;

    /**
     * Driver for testing PathOptimize
     * 
     * @param args passed in command line arguments (none expected)
     */
    public static void main(String[] args)
    {
    	final String optPathFile = ScrollablePicture.optPathFile;
    	final String optLocFile = ScrollablePicture.optLocFile;
    	final String binaryPoints = ScrollablePicture.binaryPoints;
    	final String binaryLocations =  ScrollablePicture.binaryLocations;
    	final String binaryEdges = ScrollablePicture.binaryEdges;
		String XMLPathFile = null;
		String XMLLocFile = null;
    	if(args.length == 2)
    	{
    		XMLPathFile = args[0];
    		XMLPathFile = args[1];
    		System.err.println("Using command line specified " +
    				"XML Path file: " + XMLPathFile + 
    				", XML Location File: " + XMLLocFile);
    	}
    	else
    	{
    		XMLPathFile = ScrollablePicture.XMLPathFile;
    		XMLLocFile = ScrollablePicture.XMLLocFile;
    		System.err.println("Using XML Path file: " + XMLPathFile + 
    				", XML Location File: " + XMLLocFile + 
    				"\nTo specify files via command line use:" +
    				"PathOptimize pathFile locationFile");
    	}
    	run(XMLFileIO.loadPaths(XMLPathFile), 
    			XMLFileIO.loadLocations(XMLLocFile), optPathFile, optLocFile,
    			binaryPoints, binaryLocations, binaryEdges
    	);
    }

	/**
	 * This method is used to run PathOptimized on raw data generated
	 * by ShowImage.  Follow through the comments to see the process that this
	 * method goes through.
	 * <br><br>
	 * @param inPaths The raw path data from ShowImage
	 * @param inLocations The "raw" location data from ShowImage
	 * @param outPathFile The filename to write "optimized" raw data to
	 * @param outLocFile  The filename to write "optimized" location data to
	 * @param binaryPoints The filename to write binary point data to 
	 * @param binaryLocations The filename to write binary location data to
	 * @param binaryEdges The filename to write binary edge data to
	 * @return True all the time, for no reason whatsoever...  :)
	 */
    public static boolean run(Vector <Vector<Point>>inPaths, 
			Vector <Location> inLocations,
    		String outPathFile, String outLocFile, 
			String binaryPoints, String binaryLocations, String binaryEdges)
    {
    	PathOptimize pathOp = new PathOptimize();
    	
    	/**
    	 * This reads in the Vector of vector of points and Vector of 
    	 * locations.  These go into the field readPoints and readLocation.
    	 */
		pathOp.readPaths = inPaths;
		pathOp.readLocations = inLocations;

    	/**
    	 * Convert the incoming paths of points that we read in
    	 * They come in as Vectors of a Vectors of Points
    	 * That is, it's a Vector where each element of the vector
    	 * contains a Vector which contains points
    	 * Takes the points from readLocations and readPoints.  
    	 */
		System.err.print("\tConverting Points to PathPoints.....");
    	pathOp.convertPointsToPathPoints();
    	/**
    	 * Data is now all stored in the pathPoints vector
    	 */
    	System.err.println("done: " + pathOp.pathPoints.size() + " points.");

		System.err.print("\tCollapsing duplicate PathPoints.....");
    	//Collapse all duplications of PathPoints.  
    	pathOp.condensePathPoints();
		System.err.println("done: " + pathOp.pathPoints.size() 
				+ " points after collapsing.");
    	
		System.err.print("\tHandling intersection of paths.....");

    	/**
    	 * Create new pathPoints at intersections and redirect "links" of 
    	 * the points that caused the intersections to the intersection
    	 * point
    	 */
    	pathOp.intersections();
    	System.err.println("done.");
		
		System.err.print("\tConverting PathPoints to Graph Points.....");
		pathOp.convertPathPointsToGraphPoints();
		System.err.println("done.");
		
		System.err.print("\tConverting GraphPoints down to plain points" +
				" and writing path and location objects.....");
    	pathOp.convertGraphPointsToPoints();
    	pathOp.writePoints(outPathFile, outLocFile);
		System.err.println("done.");

        System.err.print("Ensuring all ID numbers are contiguous and minimal...");
        pathOp.checkIDs();
		System.err.println("done.");
		
		System.err.print("\tWriting out to binary files.....");
    	pathOp.binaryWrite(binaryPoints, binaryLocations, binaryEdges);
		System.err.println("done.");
		
		System.err.println("====== Path Optimize complete! ======");
		System.err.println("Wrote out:");
		System.err.println(pathOp.graphPoints.size() + " GraphPoints");
		System.err.println(pathOp.outEdges.size() + " Edges");
		System.err.println(pathOp.outLocations.size() + " Locations");
    	return(true);
    }
    
    /**
     * Generic constructor. 
     * Initializes all the member fields.
     */
    public PathOptimize()
    {
    	readPaths     = new Vector <Vector<Point>> ();
    	readLocations = new Vector <Location>      ();
    	pathPoints    = new Vector <PathPoint>     ();
    	outPaths      = new Vector <Vector<Point>> ();
    	outLocations  = new Vector <Location>      ();
		outEdges      = new Vector <Edge>          ();

		// reset ID numbers so they're not inflated if PathOptimize is called
		// more than once
		Edge.resetIDCount();
		GraphPoint.resetIDCount();

		if(!debugOn)
		{
			// Assign all debug flags to false
			debugBinaryEdges = false;
			debugBinaryGraphPoints = false;
			debugBinaryLocations = false;
			debugPPtoGP = false;
		}
    }
    
	/**
	 * Loads the paths and locations fields from 
     * files.  
     * 
     * This method is no longer used since we path in the locations
     * and paths vector to run();
     * 
     * 
	 * @param pathFileName
	 * @param locFileName
	 * @return Success if both pathLoadSuccess and locationLoadSuccess
	 */
    public boolean readPoints(String pathFileName, String locFileName){
        boolean pathLoadSuccess = false;
        boolean locationLoadSuccess = false;
		// Load files
		final String pathNotFound = 
			"File \"" + pathFileName + "\" not found!     ";
		final String locNotFound = "File \"" + locFileName + "\" not found!";
		// Define input files for paths and locations.
	    File pathsInputFile = new File(pathFileName);
	    File locationsInputFile = new File(locFileName);
	    
	    // Get the paths vector
	    try{
	    	// Open stream
	        ObjectInputStream pathin = new ObjectInputStream(
	                new FileInputStream(pathsInputFile));
	        // Get Vector
			// Produces a warning due to reading in an unknown object
	        readPaths = (Vector)pathin.readObject();
	        // close stream
	        pathin.close();
            pathLoadSuccess = true;
	    }
	    catch(FileNotFoundException e){
	    	System.err.println(pathNotFound);
	    }
	    catch(Exception e){
	    	System.err.println("Error in opening \"" + pathFileName + "\"!");
	    }
	    
	    // Get the locations vector
	    try{
	        // Open stream
	        ObjectInputStream locin = new ObjectInputStream(
	                new FileInputStream(locationsInputFile));
	        // Get Vector
	        readLocations = (Vector)locin.readObject();
	        //close stream
	        locin.close();
            locationLoadSuccess = true;
	    }
	    catch(FileNotFoundException e){
	    	System.err.println(locNotFound);
	    }
	    catch(Exception e){
	    	System.err.println("Error in opening \"" + locFileName + "\"!");
	    }
        
        return( pathLoadSuccess && locationLoadSuccess );
	}
    
    
    /**
	 * Convert the points and locations (from a ShowImage data file) to
	 * PathPoints.
	 * Step through all paths, and for each path, create PathPoints as you
	 * go along, all of them linked together.  
	 */
    public void convertPointsToPathPoints()
    {
    	
    	Point inPoint;  // This is the current point in the "path"
    					// that we are working with
    	
    	Location atlocation;  // The location at the "current point"
    	
    	PathPoint currentPP;  // The current Path Point we are at
    	PathPoint prevPP;  // The previous Path Point we were at
    	
    	//For each vector of points in the vector of "paths"
    	// Each path is a set of points
    	for(int pathIndex = 0; pathIndex < readPaths.size(); pathIndex++)
    	{
    		// We have no previous point initially, so set it to null.
    		prevPP = null;
    		
    		// For every point in the "path"
    		for(int elementIndex = 0;
    		elementIndex < ( (Vector)( readPaths.get(pathIndex) )).size(); 
    		elementIndex++)
    		{
    			// Return the current point that we are at
    			inPoint = pointInReadPaths(pathIndex, elementIndex);
    			
    			// Return the location at the point (method only returns a
    			// location if it exists).  So, if no location exists,
    			// atLocation is null.
    			atlocation = locationAtPoint(inPoint);
    			
    			// initialize the current PathPoint
    			// this is a constructor call.
    			currentPP = new PathPoint(inPoint, new Vector<PathPoint>(2), 
						atlocation);
    			// Add the newPathPoint to the vector of Path Points
    			pathPoints.add(currentPP);
    			
    			// As long as there is a previous point, 
    			// cross nit the two together.  
    			if(prevPP != null){
    				currentPP.addConnectedPoint(prevPP);
    				prevPP.addConnectedPoint(currentPP);
    			}
    			// The current current will become previous when the current
    			// current is no longer current.  :)
    			prevPP = currentPP;
    		}

    	}
    }
    
	/**
	 * This method converts GraphPoints to Points...
	 * This method was used for debugging.  (to load the final
	 * graph point set into ShowImage)s
	 */
    public void convertGraphPointsToPoints()
    {
    	for(int graphIndex = 0; graphIndex < graphPoints.size(); graphIndex++)
    	{
    		// Get the GraphPoint
    		GraphPoint thisGP = (GraphPoint)graphPoints.get(graphIndex);
    		// Handle locations
    		if(thisGP.locLabel != null)
    		{
				if(debugPPtoGP)
		    		System.err.println("Adding location: " + 
							thisGP.locLabel.cord + ", " + 
							thisGP.locLabel.getName());
	    		outLocations.add( thisGP.locLabel );
    		}
    	}
    }
    
    /**
     * OBSOLETE
     * Convert a set of PathPoints to a (highly unoptimized) set of paths
     * that can be read by ShowImage.
     *
     */
    public void convertPathPointsToPoints()
    {
        // loop through all PathPoints
    	for(int pathIndex = 0; pathIndex < pathPoints.size(); pathIndex++)
    	{
    		PathPoint thisPoint = (PathPoint)pathPoints.get(pathIndex);
    		
    		// if this PathPoint is associated with a location, add it to
    		// the outgoing Locations vector
    		if(thisPoint.location != null)
    		{
	    		System.err.println("Adding location: " + thisPoint.location.cord +
	    				", " + thisPoint.location.getName());
	    		outLocations.add( thisPoint.location );
    		}
    		
    		// if this PathPoint has no connections, just add it as a single
    		// one-point path, and move on.
    		if(thisPoint.numConnectedPoints() == 0)
    		{
    			Vector <Point>thisPath = new Vector<Point>(2);
    			thisPath.add( thisPoint.point );
    			outPaths.add(thisPath);
    			continue;
    		}
    		
    		// otherwise, loop through each of this PathPoint's connections
    		for(int conPoint = 0; conPoint < thisPoint.numConnectedPoints();
    				conPoint++)
    		{
    			// create a new vector to represent this path
    			// (which consists of only two points)
    			Vector <Point>thisPath = new Vector<Point>(2);
    			thisPath.add( thisPoint.point );
    			thisPath.add( thisPoint.getConnectedPoint(conPoint) );
    			
    			// add the new vector to the list of paths
    			outPaths.add(thisPath);
    		}
    	}
    }

	/**
	 * Write ShowImage-style data to disk.
	 * @param pathFileName 
	 * @param locFileName
	 */
    public void writePoints(String pathFileName, String locFileName){
    	String errors = null;
    	String returnStatus = 
    		XMLFileIO.writeLocations(locFileName, outLocations);
    	if(returnStatus != null)
    		errors = returnStatus;
    	returnStatus = XMLFileIO.writePaths(pathFileName, outPaths);
    	if(returnStatus != null)
    		errors += returnStatus;
    	if(errors != null)
    	{
    		System.err.println("=========\nError writing optimized data to XML:" +
    				"\n" + errors + "=========");
    	}
//		ScrollablePicture.writeData(pathFileName, locFileName, 
//				outPaths, outLocations);
	}

	/**
	 * Make sure certain IDs are minimal and contiguous. This means that they
     * start at 1 and have no gaps. Currently we only check Edge IDs, because
     * they're the only ones stored in constant-record-width files, where it
     * actually matters.
	 */
    public void checkIDs(){
        int id = 1;
        for(Edge e: outEdges){
            if(e.ID != id){
                System.err.println("Edge ID " + e.ID + " (at index " + id
                    + ") is incongruous! THIS IS A BUG!");
                System.err.println("Only the first error is reported.");
                System.err.println("Ending integrity check.");
                return;
            }
            id++;
        }
    }

	/**
	 * Write data to disk in binary format, suitable for reading from
     * the web-based frontend.
	 * @param pointFileName
	 * @param locFileName
	 * @param edgeFileName
	 */
	public void binaryWrite(String pointFileName, String locFileName,
    		String edgeFileName)
	{
		if(debugBinaryEdges || debugBinaryLocations || debugBinaryGraphPoints)
			System.err.println("\n======  START OF BINARY FILE OUTPUT  " +
					"======\n");
		
        // output point data
        try{
            DataOutputStream pointOut = new DataOutputStream(
					new BufferedOutputStream(
							new FileOutputStream(new File(pointFileName))));

			if(debugBinaryGraphPoints)
				System.err.println("===== GraphPoints =====");
            // for each GraphPoint
			for(GraphPoint gp : graphPoints)
			{
				gp.binaryWrite(pointOut);
			}
			
            //close stream
            pointOut.close();
			if(debugBinaryGraphPoints)
				System.err.println("==== END of GraphPoints ====");
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + pointFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
	    
	    // output location data
        try{
            DataOutputStream locOut= new DataOutputStream(
					new BufferedOutputStream(
							new FileOutputStream(new File(locFileName))));
            
			if(debugBinaryLocations)
				System.err.println("===== Locations =====");
            // for each Graphpoint that may contain a location
			for(GraphPoint gp : graphPoints)
			{
				gp.binaryWriteLocation(locOut);
			}
			
            //close stream
            locOut.close();
			if(debugBinaryLocations)
				System.err.println("==== END of Locations =====");
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + locFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
	    
	    // output edge data
        try{
			if(debugBinaryEdges)
				System.err.println("===== Edges =====");
			
            DataOutputStream edgeOut= new DataOutputStream(
					new BufferedOutputStream(
							new FileOutputStream(new File(edgeFileName))));
            
			int maxNumPointsPerEdge = 0;
			
			// Get the maximum number of points in the set of edgegs...
			for (Edge tempEdge : outEdges) {
				if(tempEdge.path.size() > maxNumPointsPerEdge)
					maxNumPointsPerEdge = tempEdge.path.size();
			}
			
			
			final int SIZE_OF_INT = 4;
			final int POINT_SIZE = 2*SIZE_OF_INT;
			
			// Write out the # number of bytes per edge...(constant)
			edgeOut.writeInt(
					// Graphpoint ID
					// EdgePoint1 ID
					// EdgePoint2 ID
					// Number of points
					4*SIZE_OF_INT +
					// The Points + their buffer
					POINT_SIZE*maxNumPointsPerEdge
			);
			
            // for each Edge
            for(int i = 0; i < outEdges.size(); i++)
            {
            	(outEdges.get(i)).binaryWrite(edgeOut, maxNumPointsPerEdge);
            }
            //close stream
            edgeOut.close();
			if(debugBinaryEdges)
				System.err.println("==== END of Edges ====");
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + edgeFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
		if(debugBinaryEdges || debugBinaryLocations || debugBinaryGraphPoints)
			System.err.println("\n======  END OF BINARY FILE OUTPUT  ======");
    }
	
    /**
     * Return a Location (from readLocations) that corresponds with the given
     * Point (from readPaths).
     * @param pointToCompare Point to compare for locations
     * @return the Location associated with pointToCompare, or null if none
     * is found.
     */
    public Location locationAtPoint(Point pointToCompare)
    {
    	for(int locIndex = 0; locIndex < readLocations.size(); locIndex++){
			if ((getReadLocation(locIndex).cord).equals(pointToCompare))
			{
				return(getReadLocation(locIndex));
			}
    	}
    	return(null);
    }
    
    /**
     * Get the location at the given index in the readLocations Vector.
     * @param locIndex Index of Location to return
     * @return the Location at locIndex
     */
    public Location getReadLocation(int locIndex){
    	return((Location)readLocations.get(locIndex));
    }
    
    /**
     * Return a Point in a "path" in the vector of "paths".
     * The "path" to choose from the Vector of paths is specified by pathIndex.
     * The point in the "path" to grap is specified by elementIndex.
     * 
     * @param pathIndex The index determining the path to choose.
     * @param elementIndex The index determining the element in the path.
     * @return point at a given path index in a given path.  
     */
    public Point pointInReadPaths(int pathIndex, int elementIndex)
    {
    	return( (readPaths.get(pathIndex)).get(elementIndex) );    	
    }
    
    /**
     * Condense all overlapping PathPoints into single PathPoints with
     * appropriate links.
     */
    public void condensePathPoints ()
    {
		// active PathPoint (the one who we will use to check for overlaps)
    	PathPoint active;
    	
		// Set overlap PathPoint (the one that is a candidate for removal)
    	PathPoint overlap;
    	
    	//a PathPoint that is connected to the overlap PathPoint
    	PathPoint overlapConnection;
    	
    	// Loop through all PathPoints in Paths Vector
    	for(int activeIndex = 0; activeIndex<pathPoints.size(); activeIndex++){
    		// Set active PathPoint (the one to check for overlaps)
    		active = getPathPoint(activeIndex);
    		
    		// Loop through all path points again to look for intersections
    		for(int overlapIndex = activeIndex + 1; 
    			overlapIndex < pathPoints.size(); overlapIndex++)
    		{
    			// If the active PathPoint intersects with a PathPoint, 
    			// then that PathPoint is an overlap PathPoint
    			if(getPointAtPathPointsIndex(activeIndex).equals(
    					getPointAtPathPointsIndex(overlapIndex)))
    			{
    				// Set overlap PathPoint (the one that is going to be
    				// removed
    				overlap = getPathPoint(overlapIndex);
    				// For all points that are connected to that overlap 
    				// PathPoint
    				// ... link the connected pathPoints to the active 
    				// PathPoint
    				for(int conPointIndex = 0; 
    						conPointIndex < overlap.numConnectedPoints();
    						conPointIndex++)
    				{
    					// Set the PathPoint that is connected to the 
    					// overlap PathPoint
    					overlapConnection = 
    						overlap.getConnectedPathPoint(conPointIndex);
    					
    					// Remove the overlap PathPoint from the PathPoint
    					// that is/was connected to the overlap PathPoint
    					overlapConnection.removeConnectedPoint(overlap);
    					
    					// Add the active (the PathPoint we are overwriting
    					// over the overlap PathPoint) to the PathPoint
    					// that was connected to the overlap PathPoint.
    					overlapConnection.addConnectedPoint(active);
    					
    					// Add the connected PathPoint to the active
    					// PathPoint
    					active.addConnectedPoint(overlapConnection);
    				}
    				
    				// Remove the overlapping PathPoint
    				pathPoints.remove(overlap);
                    
                    // we just removed this item, so decrement the index
                    overlapIndex--;
    			}
    		}
    	}
        
        // this part doesn't actually _do_ anything: rather, it's an integrity
        // check to make sure all the duplicate points were removed.
        // (I'm paranoid.)
        for(PathPoint a: pathPoints){
            for(PathPoint o: pathPoints){
                if(a == o)
                    continue;
                if(a.point.equals(o.point))
                    System.err.println("ERROR: Overlapping PathPoints!");
            }
        }
    }
    
    /**
     * Find all intersections of connections from PathPoints, and add new,
     * connected PathPoints at these spots.
     */
    public void intersections ()
    {
    	PathPoint ap1;  // Active point 1
    	PathPoint ap2;  // Active point 2
    	PathPoint tp1;  // Test point 1
    	PathPoint tp2;  // Test point 2
    	
    	// The intersect coordinates
    	double intersectX;
    	double intersectYTest;
    	double intersectYActive;
    	double activeSlope;
    	double testSlope;
    	
    	boolean intersect = false;  // For vertical test
    	int ovIndex;
    	// Loop through all PathPoints in Paths Vector
    	for(int activeIndex1 = 0; activeIndex1<pathPoints.size(); 
    	activeIndex1++)
    	{
    		// store the first point in our active line segment
    		ap1 = getPathPoint(activeIndex1);
    		
			// For all points that are connected to that active point 1 
			// PathPoint
    		
			// now loop through all the points, again
			for(int testIndex1 = 0; testIndex1<pathPoints.size(); 
	    		testIndex1++)
	    	{
			    // store the first point in the test line segment
	    		tp1 = getPathPoint(testIndex1);
	    		//If the test point and active point are the same
	    		// Get a new test point.  
	    		if(tp1.equals(ap1))
	    			continue;
    		
AP1:    		for(int activeIndex2 = 0; 
					activeIndex2 < ap1.numConnectedPoints();
					activeIndex2++)
				{
	
					// the second point in the active line segment
					ap2 = ap1.getConnectedPathPoint(activeIndex2);
					// if the test point as  the second active point,
					// skip it.  If the 2nd active point is the same
					// as the first, skip it.  
					if(tp1.equals(ap2) || ap1.equals(ap2))
						continue;
					
					// test if this line (ap1-ap2) represents a bridge, tunnel,
					// etc.
					if(!ap1.allowLink(ap2))
						continue;
                    
					activeSlope = getSlope(ap1, ap2);
		    		
					// For all points that are connected to that test point 1 
					// PathPoint
					for(int testIndex2 = 0; 
						testIndex2 < tp1.numConnectedPoints();
						testIndex2++)
					{
					    // store the second point in the test line segment
						tp2 = tp1.getConnectedPathPoint(testIndex2);
						
						// if _this_ point is one of the active points, skip it
						// if _this_ point is the same as the first test point
						// skip!
			    		if(tp2.equals(ap1) || tp2.equals(ap2) 
			    				|| tp2.equals(tp1))
			    			continue;
						
			    		
			    		// test if this line (tp1-tp2) represents a bridge, tunnel,
						// etc.
						if(!tp1.allowLink(tp2))
							continue;
						
			    		// this is The Rectangle Test
			    		if(!rectangleTest(ap1, ap2, tp1, tp2))
			    			continue;
			    		
						// Debug printing of the active and test points
						if(intersectDebug)
						{
							System.err.print("ap1: (" + ap1.point.x + ", " + 
									ap1.point.y + ") ");
						
							System.err.println(";  ap2: (" + ap2.point.x + 
									", " + ap2.point.y + ") ");
							
							System.err.print("tp1: (" + tp1.point.x + ", " + 
									tp1.point.y + ") ");
							
							System.err.println(";  tp2: (" + tp2.point.x + 
									", " + tp2.point.y + ") ");
							
							System.err.println("Active slope: " + activeSlope);
						}
			    		
						testSlope = getSlope(tp1, tp2);

						//System.err.println("Test slope: " + testSlope);
						
						if(testSlope == activeSlope)
							continue;

						// calculate the possible X intersect coordinate
						intersectX =
							((  (activeSlope*(ap1.point.x) - ap1.point.y)
								- (testSlope*(tp1.point.x) - tp1.point.y))/
							   (activeSlope - testSlope));
						
						// calculate the two possible Y intersect coordinates
						intersectYTest = ((testSlope)
						        * (intersectX - tp1.point.x) + tp1.point.y);
						intersectYActive = ((activeSlope)
						        * (intersectX - ap1.point.x) + ap1.point.y);
						
						// if the two Y intersect coordinates are the same,
						// it's a real intersection
						
						// If vertical line!
						if(Double.isInfinite(activeSlope) && 
								Double.isInfinite(testSlope))
							continue;
						intersect = false;
						if(Double.isInfinite(activeSlope) && 
								!Double.isInfinite(testSlope))
						{
							intersectYTest = ((testSlope)
									*(ap1.point.x-tp1.point.x) + tp1.point.y);
							intersect = 
								checkRange(ap1.point.y, 
										ap2.point.y, intersectYTest);
							intersectX = ap1.point.x;
						}
						if(Double.isInfinite(testSlope) && 
								!Double.isInfinite(activeSlope))
						{
							intersectYActive = ((activeSlope)
							        * (tp1.point.x - ap1.point.x) + ap1.point.y);
							intersect = 
								checkRange(tp1.point.y, 
										tp2.point.y, intersectYActive);
							intersectX = tp1.point.x;
						}
						// Debug print of the active and intersect slopes
						if(intersectDebug)
							System.err.println("iA: " + intersectYActive + "\n" 
									+ "iT: " + intersectYTest);
						if((intersect
						|| Math.abs(intersectYActive-intersectYTest) < 0.00001))
						{
							// Debug printing if the points inersect
							if(intersectDebug){
								System.err.println("Points are equal!");
								System.err.println("(" + intersectX + ", " 
										+ intersectYTest + ")");
							}
							// (this is actually supposed to be "P-sub-i", not
                            // the Greek letter Pi.)
							// create a PathPoint in the location of the
							// potential intercept point
							PathPoint pi = new PathPoint(
							        new Point( (int)intersectX,
							                (int)intersectYTest),
							        new Vector<PathPoint>(2), null );
							
							if(intersectDebug)
								System.err.println("pi: (" + pi.point.x + ", " 
										+ pi.point.y + ") ");
							
							// ensure that the potential point is actually on
							// both lines
							if(!pointInSegments(ap1, ap2, tp1, tp2, pi))
								continue;
							
							// congratulations, you've found an intercept!
							
							if ((ovIndex = checkForPathPointOverlap(pi)) != -1)
							{
								pi = (PathPoint)pathPoints.get(ovIndex);
								// and integrate the new point with its neighbors
								if(!pi.equals(ap1) && !pi.equals(ap2))
									twoWayIntersectReplace(ap1, ap2, pi);
								
								if(intersectDebug)
									System.err.println("pi, 1: " + pi);
								
								if(!pi.equals(tp1) && !pi.equals(tp2))
									twoWayIntersectReplace(tp1, tp2, pi);
								
								if(intersectDebug)
									System.err.println("pi, 2: " + pi);

							}
							else
							{
								// add the new point to the main points Vector
								pathPoints.add(pi);
								twoWayIntersectReplace(ap1, ap2, pi);
								twoWayIntersectReplace(tp1, tp2, pi);
							}

							if(intersectDebug){
								System.err.println("pi, after: " + pi);
								
								System.err.println("ap1, after: " + ap1);
								System.err.println("ap2, after: " + ap2);
								System.err.println("tp1, after: " + tp1);
								System.err.println("tp2, after: " + tp2);
							}
							// since we've found an intercept, abort this
							// entire test line, and move on to the next 
							// 'active point 2'
							continue AP1;
						}
						
					}
		    	}

			}
    	}
		if(intersectDebug)
			System.err.println("End intersections().");
    }
    
	/**
	 * Checks to see if the passed in Path Point has an intersection
	 * with any other pathPoints.  Returns the index
	 * of the PathPoint in the pathPoints vector.
	 * @param pi The PathPoint to check for overlaps with...
	 * @return The index in the pathPoints vector of the first
	 * pathPoint found that contains an intersection
	 */
    public int checkForPathPointOverlap(PathPoint pi)
    {
		// Loop through all path points again to look for intersections
		for(int overlapIndex = 0; overlapIndex < pathPoints.size();
			overlapIndex++)
		{
			// If the active PathPoint intersects with a PathPoint, 
			// then that PathPoint is an overlap PathPoint
			if(pi.point.equals(
					getPointAtPathPointsIndex(overlapIndex)))
			{
				if(intersectDebug)
					System.err.println("Identical PathPoint found " +
							"for intersections");
				return(overlapIndex);
			}
		}
		return(-1);
    }

	/**
	 * Checks whether testVal is between val1, val2. 
	 * @param val1 
	 * @param val2
	 * @param testVal
	 * @return True if testVal is between val1, val2, false otherwise.
	 */
    public boolean checkRange(double val1, double val2, double testVal)
    {
		if(intersectDebug)
			System.err.println("CHECKRANGE:");
    	double min = Math.min(val1, val2);
    	double max = Math.max(val1, val2);
		if(intersectDebug)
    		System.err.println("Min: " + min + " Max: " + max 
					+ "test: " + testVal);
    	if(testVal < min)
    		return(false);
    	if(testVal > max)
    		return(false);
    	return(true);
    }
    /**
     * Test if a given point is in the rectangle defined by two lines.
     * (If it is, it's _possible_ that the line is the intersect point of
     * the two lines. This function is used as one of the screening tests for
     * that.)
     * @param ap1 first point in first test line
     * @param ap2 second point in first test line
     * @param tp1 first point in the second test line
     * @param tp2 second point in the second test line
     * @param pi the point to test
     * @return true if pi is in the common area of the rectangles defined by 
     * the lines ap1-ap2 and tp1-tp2, false otherwise.
     */    
    public boolean pointInSegments(PathPoint ap1, PathPoint ap2, PathPoint tp1,
    		PathPoint tp2, PathPoint pi)
    {
    	Rectangle rec1 = createRectangle(ap1.point,ap2.point);
    	// if the point isn't in the first rectangle, it can't be in both
    	if(!rec1.contains(pi.point))
    		return(false);
    	
    	Rectangle rec2 = createRectangle(tp1.point, tp2.point);
    	// if the point isn't in the second rectangle, it can't be in both
    	if(!rec2.contains(pi.point))
    		return(false);
    	
    	// by this point, we've tested both rectangles
    	return(true);
    }
    
    /**
     * Test if the rectangles defined by the line segments ap1-ap2 and
     * tp1-tp2 intersect. If they don't, the two lines cannot possibly
     * intersect (but just because the rectangles intersect doesn't mean
     * the lines do).
     * @param ap1 first point in first test line
     * @param ap2 second point in first test line
     * @param tp1 first point in the second test line
     * @param tp2 second point in the second test line
     * @return A rectangle...that is the intersection of two 
     * rectangles based on the two lines.  
     */
    public boolean rectangleTest(PathPoint ap1, PathPoint ap2, PathPoint tp1,
    		PathPoint tp2)
    {
    	Rectangle rec1 = createRectangle(ap1.point,ap2.point);
    	Rectangle rec2 = createRectangle(tp1.point, tp2.point);
    	return(rec1.intersects(rec2));
    }
    
    /**
     * Create a Rectangle object defined by the two given points. Order
     * does not matter.
     * @param p1 A point defining one corner of the Rectangle
     * @param p2 A point defining the other corner of the Rectangle
     * @return A rectangle with corners at the given points.
     */
    public Rectangle createRectangle(Point p1, Point p2)
    {
    	int x = Math.min(p1.x, p2.x);
    	int y = Math.min(p1.y, p2.y);
    	int height = Math.abs(p2.y - p1.y);
    	int width = Math.abs(p2.x - p1.x);
    	return(new Rectangle( x, y, width + 1, height + 1));
    }

    /**
     * Call intersectReplace on both combinations of p1 and p2, to effect a 
     * full integration of pi into the line segment connecting p1 and p2.
     * 
     * see intersectReplace
     * 
     * @param p1 One end of a line segment
     * @param p2 The other end of a line segment
     * @param pi A point on the line between p1 and p2
     */
    public void twoWayIntersectReplace(PathPoint p1, PathPoint p2,
            PathPoint pi)
    {
        intersectReplace(p1, p2, pi);
        intersectReplace(p2, p1, pi);
    }
    
    /**
     * Integrate one point (pi) into the line segment between two other points
     * (p1 and p2). This only connects the paths going between pi and p1. To
     * full integrate a node, this function must be called twice, swapping p1
     * and p2 on the second call.
     * 
     * @see twoWayIntersectReplace
     *
     * @param p1 One end of a line segment
     * @param p2 The other end of a line segment
     * @param pi A point on the line between p1 and p2
     */
    private void intersectReplace(PathPoint p1, PathPoint p2, PathPoint pi)
    {
    	//remove p2 from p1
    	p1.removeConnectedPoint(p2);
    	//add pi to p1
    	p1.addConnectedPoint(pi);
    	//add p1 to pi
    	pi.addConnectedPoint(p1);
    }
    
    /**
     * Get the slope between two points.
     * @param p1 The first point
     * @param p2 The second point
     * @return the slope between p1 and p2, as a double
     */
    public static double getSlope(PathPoint p1, PathPoint p2)
    {
    	if(p2.point.x == p1.point.x)
    	{
    		//throw new RuntimeException("Non real slope");
    	}
    	return(((double)(p2.point.y - p1.point.y))/
    			((double)(p2.point.x - p1.point.x)));
    }

    
    
    /**
     * Return the Point contained in the PathPoint at the given index in
     * the pathPoints vector.
     * @param index the index to check
     * @return the Point in the PathPoint at the index
     */
    public Point getPointAtPathPointsIndex(int index)
    {
    	return( ( (PathPoint)pathPoints.get( index ) ).point );
    }
    
    /**
     * Return the PathPoint at the given index in the pathPoints vector.
     * @param index the index to check
     * @return the PathPoint at the index
     */
    public PathPoint getPathPoint(int index)
    {
    	return((PathPoint)pathPoints.get( index ) );
    }
    
    
    
    /**
     * See method from hell that calls hell...
     * 
     * Okay, fine, it really isn't that bad...but still
     * 
     * This method converts the PathPoints vector that was loaded from
     * raw path data generated by ShowImage into GraphPoints.
     * GraphPoints are the optimized connected graph.  
     */
    public void convertPathPointsToGraphPoints()
    {
    	GraphPoint gp;
    	PathPoint curPP;
    	PathPoint graphPP;
    	Edge tempEdge;
    	int ppIndex;
    	int conIndex;
    	PathPoint prevPP, whereFrom;
    	
    	// the index, if any, of the Edge pointing from an endpoint to the 
    	// original point
    	int edgeIndex = 0;
    	
    	graphPoints = new Vector<GraphPoint>();
    	
    	// create a GraphPoint for every "significant" PathPoint
    	for(ppIndex = 0; ppIndex < pathPoints.size(); ppIndex++)
    	{
    		if(getPathPoint(ppIndex).isGraphPoint())
    		{
    			// the constructor does the linking between the PathPoint
    			// and the new GraphPoint
    			gp = new GraphPoint(getPathPoint(ppIndex));
    			graphPoints.add(gp);
				if(debugPPtoGP)
					System.err.println("Making " + getPathPoint(ppIndex) + 
							" a GraphPoint.");
    		}
    	}
    	
    	// for all pathPoints
    	for(ppIndex = 0; ppIndex < pathPoints.size(); ppIndex++)
    	{
    		// For all significant PathPoints
    		if(!getPathPoint(ppIndex).isGraphPoint())
    			continue;
    		
    		// This gets a significant PathPoint
    		graphPP = getPathPoint(ppIndex);
    		
			if(debugPPtoGP)
				System.err.println("Signficant PathPoint " 
						+ graphPP.toString());
    		
    		// For all connections of significant PathPoints
    		for(conIndex = 0; conIndex < graphPP.numConnectedPoints();
    			conIndex++)
    		{
    			// Create new edge
				tempEdge = new Edge();
				
				// add Significant PathPoint to edge's path.
				tempEdge.path.add(graphPP.point);
				
				// Assign the endpointer
				tempEdge.endpt1 = graphPP.getGraphPoint();

				// Set the current pathPoint to be  a connection of
				// the significant pathPoint.  
    			curPP = graphPP.getConnectedPathPoint(conIndex);
    			
    			// add the connection of the significant pathPoint (a PathPoint)
    			// to the path Vector.  
    			tempEdge.path.add(curPP.point);
				
				if(debugPPtoGP)
					System.err.println("Adding point: " + curPP);

    			// Increment weight
    			tempEdge.weight += graphPP.getWeight(curPP);
    			
    			// Temporary holder for previous point
				whereFrom = graphPP;
				
				// Make what is the current point also the previous point
				prevPP = curPP;
				
				// Loop while we can do a pointTraversal.  
				while( (curPP = curPP.pathPointTraversal(whereFrom)) != null )
				{
					tempEdge.path.add(curPP.point);

					if(debugPPtoGP)
						System.err.println("Adding point: " + curPP);
					tempEdge.weight += prevPP.getWeight(curPP);
					whereFrom = prevPP;
					prevPP = curPP;
				}
				
				if(debugPPtoGP)
					System.err.println("Setting end");
				tempEdge.endpt2 = prevPP.getGraphPoint();
				
				// check if the end point of the Edge we just created already
				// has an Edge pointing back to the original GraphPoint.
				if(prevPP.getGraphPoint() != null)
				{
					edgeIndex = (prevPP.getGraphPoint()).outgoingEdge(
							graphPP.getGraphPoint(), tempEdge);
				}
				else
				{
					if(debugPPtoGP)
						System.err.println("Working with an end that needs" +
								" to be discarded, (isn't a graphPoint)");
					tempEdge.discard();
					continue;
				}
				if(debugPPtoGP)
					System.err.println("Edge Index = " + edgeIndex);
				if(edgeIndex != -1)
				{
					// if it does, we just attach to the existing edge, and
					// discard the one we created
					graphPP.getGraphPoint().edges.add(
							prevPP.getGraphPoint().getEdge(edgeIndex));
					
					// this decrements the Edge class' static ID count
					tempEdge.discard();
					if(debugPPtoGP)
						System.err.println("  --Discarding edge--");
				}
				else{
					if(debugPPtoGP){
						System.err.println("  --Added edge--");
						System.err.println("tempEdge's ID:" + tempEdge.ID);
						System.err.println(" To graph: " 
								+ graphPP.getGraphPoint().ID);
					}
					
					// take significant pathPoint, get its corresponding
					// graph point.  Use that point to add the new edge created
					// to the graph point's edge vector.  
					( graphPP.getGraphPoint() ).edges.add(tempEdge);
					
					// save the edge's path we added so we can print it later
					outPaths.add(tempEdge.path);
					outEdges.add(tempEdge);
				}
				
    		}
    		
    	}
		if(debugPPtoGP)
	    	for(int graphPI = 0; graphPI < graphPoints.size(); graphPI++)
	    		 System.err.println(((GraphPoint)graphPoints.get(graphPI)));
    }
    
    
    
    
}

/**
 * A Point that contains a list of the PathPoints it is connected to, as well 
 * as an optional pointer to an associated Location.
 */
class PathPoint
{
	// Point where the PathPoint is located at
	Point point;

	// This field is a vector of Points that are
	// connected to the PathPoint's point.
	Vector <PathPoint> connectedPoints;
	// Any location associated with the point
	Location location;
	
	private GraphPoint graphPoint = null;

	/**
	 * @return Returns the graphPoint.
	 */
	public GraphPoint getGraphPoint() {
		return graphPoint;
	}
	/**
	 * @param graphPoint The graphPoint to set.
	 */
	public void setGraphPoint(GraphPoint graphPoint) {
		this.graphPoint = graphPoint;
	}
	
	/**
	 * Tests to see if two points have the same location.
	 * @param p
	 * @return True if the two points equal, false otherwise.
	 */
	public boolean equals(PathPoint p)
	{
		return( ( p.point ).equals( point ) );
	}
	
	
	/**
	 * Simple constructor for making path points.
	 * Simply initilize the 3 main fields of pathPoints.  graphPoint is
	 * initilized to null since we don't even know about graphPoints yet.
	 * (If you're following through the program, don't think about 
	 * graphPoints yet). 
	 * @param inPoint What to initilize the Point field point to.  
	 * @param inConnectPoints What to initilize the Vector field 
	 * connetedPoints to.  This field is a vector of Points that are
	 * connected to the PathPoint's point.
	 * @param inLoc The location to initilize the PathPoint to
	 * The location is the location associated with PathPoint's point.
	 */
	public PathPoint(Point inPoint, Vector <PathPoint>inConnectPoints, 
			Location inLoc){
		// Simply initilize the fields to the ones passed in.  
		point = inPoint;
		connectedPoints = inConnectPoints;
		location =  inLoc;
	}
	
	/**
	 * Add the given point to this point's connectedPoints vector.
	 * @param p Point to add
	 */
	public void addConnectedPoint(PathPoint p)
	{
		if(p != null)
			connectedPoints.add(p);
	}
	
	/**
	 * Remove the given point from this point's connectedPoints vector.
	 * @param p Point to remove
	 * @return true if the point was was found and could be removed, false
	 * otherwise.
	 */
	public boolean removeConnectedPoint(PathPoint p)
	{
		return connectedPoints.remove(p);
	}
	
	/**
	 * Get the number of connected points
	 * @return number of connected points
	 */
	public int numConnectedPoints(){
		return(connectedPoints.size());
	}
	/**
	 * Get the point at given index in Vector of connected points
	 * @param index Index to get point from
	 * @return point at given index
	 */
	public Point getConnectedPoint(int index){
		return((Point)getConnectedPathPoint(index).point);
	}
	
	/**
	 * Get the PathPoint at given index in Vector of connected points.
	 * @param index Index to get PathPoint from
	 * @return point at given index
	 */
	public PathPoint getConnectedPathPoint(int index){
		return((PathPoint)connectedPoints.get(index));
	}

	/**
	 * Checks to see if a line (represented by the calling PathPoint
	 * and the passed in PathPoint) represents a PathPoint we don't want
	 * to have a intersection on.  
	 * Returns true only if both use the tag '&lt;nolink&gt;'
	 * 
	 * @param other The PathPoint to use to simulate the line.
	 * @return True if no intersection should be drawn.  False otherwise.
	 */
	public boolean allowLink(PathPoint other)
	{
        // PathPoints that don't have locations can't suppress linking
        // (this also guards against null-pointer exceptions below)
        if(location == null || other.location == null)
            return true;
        
        return (location.isAllowIntersections()
                &&  other.location.isAllowIntersections()
                );
	}
	
	/**
	 * Checks to see if the point is a GraphPoint (also talked about as a
	 * significant point).  
	 * So, if the graphPoint has no connected points, it won't become
	 * a graphPoint.  Since by definition it's not connected to a graphPoint,
	 * and we're creating the graph based on GraphPoints, the non-connected
	 * point will disappear from the graph!
	 * @return True if the point has more than 2 connected points. 
	 * Also returns true if the point has a location label.   
	 */
	public boolean isGraphPoint()
	{
		if(numConnectedPoints() > 2){
			if(PathOptimize.debugPPtoGP)
				System.err.println("#con pts > 2 ==> isGraphPoint = true");
			return(true);
		}
		// Null guard to prevent exceptions
		
		// TODO: Deletion of unnecessary locations is here...
		if(location != null){
			if(PathOptimize.debugPPtoGP)
				System.err.println("Location ==> isGraphPoint = true");
			return(true);
		}
		if(PathOptimize.debugPPtoGP)
			System.err.println("isGraphPoint returns false");
		return(false);
	}
	
	/**
	 * This method is used by convertPathPointsToGraphPoints.  
	 * It is used to let us traverse through PathPoints until a GraphPoint 
	 * is found.  The function will return null is the point is a GraphPoint.
	 * This also checks to ensure that the this PathPoint only has two
	 * connections.  We then return the connection to the thisPoint that
	 * is not the previous PathPoint.  
	 * 
	 * @param prevPoint The point that we were previously at in the traversal.
	 * @return The next pathPoint in the traversal.  
	 */
	public PathPoint pathPointTraversal(PathPoint prevPoint)
	{
		// This could be written better...but it works...
		// Basically, we're checking if a next point exists
		if(isGraphPoint() || (numConnectedPoints() == 1) )
			return(null);
		
		if(prevPoint == getConnectedPathPoint(0))
			return(getConnectedPathPoint(1));
		return(getConnectedPathPoint(0));
	}
	
	/**
	 * This method gets the weight between two path points
	 * @param p Passed in pathPoint object
	 * @return The weight between the two path points (the one passed
	 * and the pathPoint used to call it).  
	 */
	public double getWeight(PathPoint p)
	{
		return(point.distance(p.point));
	}
	
	/**
	 * Print this PathPoint's x/y coordinates, the name of its associated
	 * Location (if applicable), and the coordinates of any connections it has.
	 * @return String describing the PathPoint object
	 */
	public String toString(){
		String outStr = "(" + point.x + ", " + point.y + ") ";
		if(location != null)
			outStr += " [" + location.getName() + "]";
		for(int i = 0; i < numConnectedPoints(); i++){
			outStr += "\n\t --> (" + getConnectedPoint(i).x + ", " +
				getConnectedPoint(i).y + ")";
		}
		outStr += "\n";
		
		return outStr;
	}
}

/**
 * A node in a graph, containing any number of vertices (Edge objects).
 * This is the final in-memory representation of the path data, and a direct
 * analog to the binary file format.
 */
class GraphPoint
{
	// Binary file identifier
	int ID;
	// Point where the graphpoint is located at
	Point point;
	// Set of edges connected to the graphpoint
	Vector <Edge> edges;
	// Any assocated location to the graphpoint (if exists)
	Location locLabel;
	
	// Binary file identifier
	static int IDcount = 1;
	
	/**
	 * Default constructor for GraphPoint<br>
	 * <b>Initializes fields of the GraphPoint object:<br></b>
	 * point is initialized to the point field of the passed in PathPoint<br>
	 * location is initialized to the location field of passed in PathPoint
	 * if a PathPoint contained a location<br>
	 * Initializes the edge Vector (edges will be added later)
	 * Binary ID = IDcount++;
	 * @param pp The passed in PathPoint (vertex)
	 */
	public GraphPoint(PathPoint pp)
	{
		point = new Point(pp.point);
		pp.setGraphPoint(this);
	
		// Previous location of checking for "<nolink>" in the tag
		if(pp.location != null)			
			locLabel = pp.location;

		edges = new Vector<Edge>();
		// Set the ID and increment the static variable for the next ID
		ID = IDcount++;
	}

	/**
	 * Reset the ID count, ensuring all GraphPoints get correct 1-based ID
	 * numbers.
	 */
	public static void resetIDCount(){
		IDcount =  1;
	}
	
	/**
	 * Returns an edge at the specified index of the GraphPoint.  
	 * Basically avoids the ugly casing.  
	 * @param index The specified index
	 * @return The Edge at the the specified index.  
	 */
	public Edge getEdge(int index)
	{
		return( (Edge)edges.get( index ) );
	}
	
	/**
	 * This checks if the current GraphPoint has any OUTGOING Edges
	 * that point to the passed-in point. It does NOT check incoming Edges
	 * (that is, Edges that were set from other GraphPoints).
	 * @param gp The passed-in point.
	 * @param incoming The incoming edge.
	 * @return true if current point has Edges that point to 'gp', false
	 * otherwise
	 */
	public int outgoingEdge(GraphPoint gp, Edge incoming)
	{
		// an edge that may match the incoming edge
		// (one of the calling GraphPoint's edges)
		Edge outEdge;
		boolean forward = true;
		boolean reverse = true;
		for(int i = 0; i < edges.size(); i++)
		{
			// Reset the boolean values
			forward = true;
			reverse = true;
			if(PathOptimize.debugPPtoGP)
				System.err.println("Outgoing Edge: " + getEdge(i).endpt2.point +
						" == " + gp.point);
			if(getEdge(i).endpt2 == gp){
				outEdge = (Edge)getEdge(i);
				
				if(PathOptimize.debugPPtoGP)
					System.err.println("Size condition: " + outEdge.path.size()
							+ " == " + incoming.path.size());
				if( outEdge.path.size() != incoming.path.size() )
					continue;
				
				// we know the sizes are the same now, so we don't have to
				// worry about overruning indices
				// Go through reverse order
				for(int ptIndex = 0; ptIndex < outEdge.path.size();
					ptIndex++)
				{
					if(PathOptimize.debugPPtoGP)
						System.err.println("Comparing: " + 
								outEdge.path.get(
										(outEdge.path.size() - ptIndex -1 ) ) 
								+ " and " + incoming.path.get(ptIndex));
					if(!outEdge.path.get(
							outEdge.path.size() - ptIndex -1 ).equals(
							incoming.path.get(ptIndex)))
						reverse = false;
				}

				// Go through forward order
				for(int ptIndex = 0; ptIndex < outEdge.path.size();
					ptIndex++)
				{
					if(!outEdge.path.get(ptIndex).equals(
							incoming.path.get(ptIndex)))
						forward = false;
				}
				// If one of the ways that you compared
				// the two edges turned to be true
				// Then you want to discard.  So return the index
				if(forward || reverse)
					return(i);
			}
		}
		// If no edges were  found to be equal to the passed in edge
		// Then we did not find a match, so we do not want to discard
		// In other words, we want to add
		return(-1);
	}
	
	/**
	 * Write a serialized representation of this GraphPoint to disk, using
	 * only primitive data types, so that it can be reconstructed by
	 * other applications in other languages.
	 * @param out Output stream
	 */
	public void binaryWrite(DataOutputStream out)
	{
    	// output ID of GraphPoint
		try{
			if(PathOptimize.debugBinaryGraphPoints)
				System.err.println("ID: " + ID + "      (" + point.x + ", "
						+ point.y + ")");
			out.writeInt(ID);
            out.writeInt(point.x);
            out.writeInt(point.y);
			
			// write the ID of the associated location, if there is one;
            // if there isn't, use 0 (all IDs are > 0)
            if(locLabel != null && locLabel.isDisplayName()){
                if(PathOptimize.debugBinaryGraphPoints)
                    System.err.println("Location ID: " + locLabel.ID);
                out.writeInt(locLabel.ID);
                if(PathOptimize.debugBinaryGraphPoints)
                    System.err.println("PassThrough: "
                            + locLabel.isCanPassThrough());
                out.writeByte( locLabel.isCanPassThrough() ? 1 : 0 );
            }
            else
            {
                out.writeInt(0);
                if(PathOptimize.debugBinaryGraphPoints)
                    System.err.println("Location ID: 0");
                // GraphPoints without locations are always PassThrough
                if(PathOptimize.debugBinaryGraphPoints)
                    System.err.println("PassThrough: true");
                // For no-display locations...
                if(locLabel != null)
                    // write out the passThrough property
                    out.writeByte( locLabel.isCanPassThrough() ? 1 : 0);
                else  // write default
                    out.writeByte(1);
            }
            
            // output number of connections/weights/edges
            if(PathOptimize.debugBinaryGraphPoints)
                System.err.println("Connections/weights/edges: " +edges.size());
            out.writeInt(edges.size());
            
			// for each Edge connected to this GraphPoint
			for(int i = 0; i < edges.size(); i++)
			{
				if(PathOptimize.debugBinaryGraphPoints)
					System.err.println("--Start connection--");
	    		// print ID of each connection
				//if(edges.get(i).endpt1 == this){
                if(((Edge)edges.get(i)).endpt1 == this){
					if(PathOptimize.debugBinaryGraphPoints)
						System.err.println("Connection ID (endpt2): " +
								edges.get(i).endpt2.ID);
					out.writeInt( edges.get(i).endpt2.ID );
				}
				else{
					if(PathOptimize.debugBinaryGraphPoints)
						System.err.println("Connection ID (endpt1): " +
								edges.get(i).endpt1.ID);
					out.writeInt( edges.get(i).endpt1.ID );
				}
				
				// print value of each weight
	    		out.writeInt( (int)edges.get(i).weight );
				if(PathOptimize.debugBinaryGraphPoints)
		    		System.err.println("Weight: " + edges.get(i).weight );
					
	    		// print ID of each edge
	    		out.writeInt( edges.get(i).ID );
				if(PathOptimize.debugBinaryGraphPoints)
					System.err.println("Edge ID: " + edges.get(i).ID);
			}
			
			if(PathOptimize.debugBinaryGraphPoints)
				System.err.println("---end---");
		}
		catch(IOException e)
		{
			System.err.println("Error in GraphPoint.binaryWrite!");
		}
	}
	
	/**
	 * Write data about this GraphPoint's associated Location,
	 * if it has one. If this.locLabel == null, then nothing is
	 * written to the output stream.
	 * @param out Output stream
	 */
	public void binaryWriteLocation(DataOutputStream out)
	{
		// don't do anything if the graphpoint isn't attached to a location
		// or the location isn't wanted for display
		if(locLabel == null || !locLabel.isDisplayName())
			return;
	
		try{
			// output ID of Location
			if(PathOptimize.debugBinaryLocations)
				System.err.println("Location ID: " + this.locLabel.ID);
			out.writeInt(this.locLabel.ID);
	        
            // output (x,y) coordinates of Location
			if(PathOptimize.debugBinaryLocations)
				System.err.println("Location coords: (" + this.locLabel.cord.x +
						", " + this.locLabel.cord.y + ")");
			out.writeInt(this.locLabel.cord.x);
			out.writeInt(this.locLabel.cord.y);
            
            // write out boolean flags as single bytes
			if(PathOptimize.debugBinaryLocations)
				System.err.println("DisplayName:" + this.locLabel.isDisplayName());
            out.writeByte(this.locLabel.isDisplayName() ? 1 : 0);

            // output ID of associated GraphPoint
			if(PathOptimize.debugBinaryLocations)
				System.err.println("Associated GraphPoint: " + this.ID);
			out.writeInt(this.ID);

            // output display name
			if(PathOptimize.debugBinaryLocations)
				System.err.println("Display name: " + this.locLabel.getName() 
						+ "(" + this.locLabel.getName().length() + ")");
            binWriteStr(out, this.locLabel.getName());
            //out.writeInt(this.locLabel.getName().length());
			//out.writeChars(this.locLabel.getName());
            
            // output building code
            if(PathOptimize.debugBinaryLocations)
                System.err.println("Building code: "
                        + this.locLabel.getBuildingCode() + "("
                        + this.locLabel.getBuildingCode().length() + ")");
            binWriteStr(out, this.locLabel.getBuildingCode());
            //out.writeInt(this.locLabel.getBuildingCode().length());
            //out.writeChars(this.locLabel.getBuildingCode());
            
            // output location keywords
            if(PathOptimize.debugBinaryLocations)
                System.err.println("Location keywords: "
                        + this.locLabel.getKeywords() + "("
                        + this.locLabel.getKeywords().length() + ")");
            binWriteStr(out, this.locLabel.getKeywords());
            //out.writeInt(this.locLabel.getKeywords().length());
            //out.writeChars(this.locLabel.getKeywords());
            
            // first write out the number of aliases
            if(PathOptimize.debugBinaryLocations)
                System.err.println("Location aliases (" +
                        this.locLabel.getAliases().size() + "):");
            out.writeInt(this.locLabel.getAliases().size());
            
            // then write out each alias string individually
            for(String s: this.locLabel.getAliases()){
                if(PathOptimize.debugBinaryLocations)
                    System.err.println("\t" + s);
                binWriteStr(out, s);
            }
            
			if(PathOptimize.debugBinaryLocations)
				System.err.println("---end---");
		}
	    catch(IOException e){
	    	System.err.println("Error in GraphPoint.binaryWriteLocation: "
                    + e.getMessage());
	    }
	    
	}

    /**
     * Write the given string to the given file stream in an easily-readable
     * binary format.
     * @param out output stream
     * @param str the string to write
     * @return the length of the string written
     * @throws IOException If an error occurs in writing out the string.
     */ 
    public int binWriteStr(DataOutputStream out, String str) throws IOException{
        out.writeInt(str.length());
        out.writeChars(str);
        return str.length();
    }
    
	/**
	 * Checks to see if the location label is null, if it isn't null
	 * returns the location label's name field with a newline.  
	 * @return location name if non-null, else null-string.  
	 */
	public String getLocationName()
	{
		if(locLabel != null)
			return(locLabel.getName() + "\n");
		return("");
	}
	
	/**
	 * This is a simple toString() method
	 * @return String describing the GraphPoint object.
	 */
	public String toString()
	{
		String outStr = "GraphPoint @ (" + point.x + ", " + point.y + ")\n";
		outStr += getLocationName();
		for(int i = 0; i < edges.size(); i++)
			outStr +=  ((Edge)edges.get(i)).toString();
		return(outStr);
	}
}

/**
 * A vertex between two GraphPoints, containing a list of intermediate
 * displayable points (representing the physical path the edge takes).
 *
 */
class Edge
{
	// Binary file identifier
	int ID;
	
	// The endpoints of the edge.  
	// Both of these graphs contain a pointer to this Edge.
	// (But there is only one copy of the edge)
	GraphPoint endpt1;
	GraphPoint endpt2;
	
	Vector <Point> path;  // Vector Points
	double weight = 0;
	
	// Binary file identifier
	static int IDcount = 1;
	
	/**
	 * Default constructor for edges
	 */
	public Edge()
	{
		path = new Vector <Point>();
		endpt1 = endpt2 = null;
		
		// Set the ID and increment the static variable for the next ID
		ID = IDcount++;
	}
	
	/**
	 * If we discard an edge, the decrement the ID count.
	 * This occurs because we created an edge, but did not add the edge
	 * to any graphPoints.  So, the Edge is thrown away and we want to throw
	 * away it's ID number.  
	 */
	public void discard(){
		IDcount--;
	}

	/**
	 * Reset the ID count, ensuring all Edges get correct 1-based ID
	 * numbers.
	 */
	public static void resetIDCount(){
		IDcount =  1;
	}
	
	/**
	 * toString method for Edges.  
	 * This method is used for debugging.  
	 * @return String describing the Edge object.
	 */
	public String toString()
	{
		String outStr = "End Point 1: " + endpt1.point + "\nEnd Point 2: " +
		endpt2.point + "\n";
		
		for(int i = 0; i < path.size(); i++)
		{
			outStr += "   -->" + this.getPointInPath(i).toString() + "\n";
		}
		outStr += "Total weight: " + weight + "\n";
		
		return(outStr);
	}
	
	/**
	 * This method gets a Point in the path element of edge.  
	 * @param i The index in the path to get the element from.  
	 * @return Point in the Path element of 
	 */
	public Point getPointInPath(int i)
	{
		return((Point)path.get(i));
	}
	
	/**
	 * Get's the weight (the simple distance sum) of the edge.
	 * @return weight (a double).
	 */
	public double getWeight()
	{
		return(weight);
	}
	
	/**
	 * Write a serialized representation of this Edge to disk, using
	 * only primitive data types, so that it can be reconstructed by
	 * other applications in other languages.
	 * @param out Output stream
	 * @param numPointsToWrite The number of points to write out to the file
	 * (regardless of whether they are blank or not)
	 */
	public void binaryWrite(DataOutputStream out, int numPointsToWrite)
	{
		try{
			//print ID of edge
			if(PathOptimize.debugBinaryEdges)
				System.err.println("Edge ID: " + ID);
			out.writeInt(ID);
			
	    	// print ID of starting GraphPoint
			if(PathOptimize.debugBinaryEdges)
				System.err.println("Start GraphPoint ID: " + endpt1.ID);
			out.writeInt(endpt1.ID);
			
	    	// print ID of ending GraphPoint
			if(PathOptimize.debugBinaryEdges)
				System.err.println("End GraphPoint ID: " + endpt2.ID);
			out.writeInt(endpt2.ID);
			
	    	// print number of points
			if(PathOptimize.debugBinaryEdges)
				System.err.println("Number of points: " + path.size());
			out.writeInt(path.size());

			// print ordered pairs
			for(int i = 0; i < path.size(); i++)
			{
				if(PathOptimize.debugBinaryEdges)
					System.err.println("Coordinate: (" + ((Point)path.get(i)).x
							+ ", " + ((Point)path.get(i)).y + ")");
				
				out.writeInt(((Point)path.get(i)).x);
				out.writeInt(((Point)path.get(i)).y);
			}
			
			// Write out 0s for the buffer
			for(int i = path.size(); i < numPointsToWrite; i++)
			{
				out.writeInt(0);
				out.writeInt(0);
			}
			if(PathOptimize.debugBinaryEdges)
				System.err.println("---end---");
		}
		catch(IOException e)
		{
			System.err.println("Error in Edge.binaryWrite()!");
		}
	}
}
